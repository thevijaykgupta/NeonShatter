<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Shatter - Play Online</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0a14 0%, #1a1a2e 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
            border: 2px solid rgba(0, 255, 255, 0.2);
        }
        
        canvas {
            display: block;
            background: rgb(10, 10, 20);
        }
        
        #instructions {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            text-align: center;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="instructions">Click on the game to focus, then use Arrow Keys to play</div>
    </div>

    <script>
        // Game Constants
        const WIDTH = 800;
        const HEIGHT = 600;
        const FPS = 60;
        
        // Game State
        const GameState = {
            MENU: 0,
            PLAYING: 1,
            GAME_OVER: 2,
            WIN: 3
        };
        
        // Colors
        const COLORS = {
            CYAN: 'rgba(0, 255, 255, 1)',
            MAGENTA: 'rgba(255, 0, 255, 1)',
            GREEN: 'rgba(0, 255, 0, 1)',
            YELLOW: 'rgba(255, 255, 0, 1)',
            RED: 'rgba(255, 0, 0, 1)',
            WHITE: 'rgba(255, 255, 255, 1)',
            DARK: 'rgb(10, 10, 20)'
        };
        
        const COLOR_ARRAY = [
            {r: 0, g: 255, b: 255},    // Cyan
            {r: 255, g: 0, b: 255},    // Magenta
            {r: 0, g: 255, b: 0},      // Green
            {r: 255, g: 255, b: 0}     // Yellow
        ];
        
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.tabIndex = 1000;
        canvas.focus();
        
        // Game variables
        let gameState = GameState.MENU;
        let score = 0;
        let currentLayoutIndex = 0;
        let leftPressed = false;
        let rightPressed = false;
        
        // Game objects
        let paddle, ball, bricks = [], particles = [];
        
        // Layout generators
        const layouts = [
            generateGridLayout,
            generateWaveLayout,
            generateCircleLayout,
            generateZigZagLayout
        ];
        
        // Ball class
        class Ball {
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = COLOR_ARRAY[0];
                this.reset();
            }
            
            reset() {
                const angle = Math.random() * Math.PI / 3 + Math.PI / 6;
                const baseSpeed = 4.0;
                this.velocityX = baseSpeed * Math.cos(angle);
                this.velocityY = -baseSpeed * Math.sin(angle);
            }
            
            update() {
                this.x += this.velocityX;
                this.y += this.velocityY;
            }
            
            reverseX() { this.velocityX = -this.velocityX; }
            reverseY() { this.velocityY = -this.velocityY; }
            
            setVelocity(vx, vy) {
                const speed = Math.sqrt(vx * vx + vy * vy);
                const maxSpeed = 7.0;
                if (speed > maxSpeed) {
                    vx = (vx / speed) * maxSpeed;
                    vy = (vy / speed) * maxSpeed;
                }
                this.velocityX = vx;
                this.velocityY = vy;
            }
            
            setPosition(x, y) {
                this.x = x;
                this.y = y;
            }
            
            getBounds() {
                return {
                    x: this.x - this.radius,
                    y: this.y - this.radius,
                    width: this.radius * 2,
                    height: this.radius * 2
                };
            }
            
            draw() {
                // Glow effect
                for (let i = 3; i > 0; i--) {
                    const alpha = 30 / i / 255;
                    const glowRadius = this.radius + i * 2;
                    ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, glowRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Main ball
                ctx.fillStyle = `rgb(${this.color.r}, ${this.color.g}, ${this.color.b})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius / 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Paddle class
        class Paddle {
            constructor(x, y, width, height, screenWidth) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.screenWidth = screenWidth;
                this.color = COLOR_ARRAY[1];
                this.velocity = 0;
                this.acceleration = 0.5;
                this.friction = 0.85;
                this.maxSpeed = 8.0;
            }
            
            moveLeft() {
                this.velocity -= this.acceleration;
                if (this.velocity < -this.maxSpeed) this.velocity = -this.maxSpeed;
            }
            
            moveRight() {
                this.velocity += this.acceleration;
                if (this.velocity > this.maxSpeed) this.velocity = this.maxSpeed;
            }
            
            update() {
                this.velocity *= this.friction;
                this.x += this.velocity;
                
                if (this.x < 0) {
                    this.x = 0;
                    this.velocity = 0;
                } else if (this.x + this.width > this.screenWidth) {
                    this.x = this.screenWidth - this.width;
                    this.velocity = 0;
                }
            }
            
            getBounds() {
                return { x: this.x, y: this.y, width: this.width, height: this.height };
            }
            
            draw() {
                const cornerRadius = 8;
                
                // Glow
                for (let i = 4; i > 0; i--) {
                    const alpha = 40 / i / 255;
                    const offset = i * 2;
                    ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${alpha})`;
                    this.drawRoundedRect(this.x - offset, this.y - offset, 
                                       this.width + offset * 2, this.height + offset * 2, 
                                       cornerRadius + offset);
                }
                
                // Main paddle
                ctx.fillStyle = `rgb(${this.color.r}, ${this.color.g}, ${this.color.b})`;
                this.drawRoundedRect(this.x, this.y, this.width, this.height, cornerRadius);
                
                // Highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                this.drawRoundedRect(this.x + 2, this.y + 2, this.width - 4, this.height / 2, cornerRadius);
            }
            
            drawRoundedRect(x, y, w, h, r) {
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + w - r, y);
                ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                ctx.lineTo(x + w, y + h - r);
                ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                ctx.lineTo(x + r, y + h);
                ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                ctx.lineTo(x, y + r);
                ctx.quadraticCurveTo(x, y, x + r, y);
                ctx.closePath();
                ctx.fill();
            }
        }
        
        // Brick class
        class Brick {
            constructor(x, y, width, height, color) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.destroyed = false;
            }
            
            destroy() { this.destroyed = true; }
            
            getBounds() {
                return { x: this.x, y: this.y, width: this.width, height: this.height };
            }
            
            draw() {
                if (this.destroyed) return;
                
                const cornerRadius = 6;
                
                // Glow
                for (let i = 3; i > 0; i--) {
                    const alpha = 50 / i / 255;
                    const offset = i * 2;
                    ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${alpha})`;
                    this.drawRoundedRect(this.x - offset, this.y - offset,
                                       this.width + offset * 2, this.height + offset * 2,
                                       cornerRadius + offset);
                }
                
                // Main brick
                ctx.fillStyle = `rgb(${this.color.r}, ${this.color.g}, ${this.color.b})`;
                this.drawRoundedRect(this.x, this.y, this.width, this.height, cornerRadius);
                
                // Highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.24)';
                this.drawRoundedRect(this.x + 2, this.y + 2, this.width - 4, this.height / 3, cornerRadius);
                
                // Border
                ctx.strokeStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.78)`;
                ctx.lineWidth = 1.5;
                this.drawRoundedRect(this.x, this.y, this.width, this.height, cornerRadius);
                ctx.stroke();
            }
            
            drawRoundedRect(x, y, w, h, r) {
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + w - r, y);
                ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                ctx.lineTo(x + w, y + h - r);
                ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                ctx.lineTo(x + r, y + h);
                ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                ctx.lineTo(x, y + r);
                ctx.quadraticCurveTo(x, y, x + r, y);
                ctx.closePath();
                ctx.fill();
            }
        }
        
        // Particle class
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = Math.random() * 4 + 2;
                this.maxLife = Math.random() * 20 + 15;
                this.life = this.maxLife;
                this.alive = true;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 2;
                this.velocityX = Math.cos(angle) * speed;
                this.velocityY = Math.sin(angle) * speed;
            }
            
            update() {
                if (!this.alive) return;
                this.x += this.velocityX;
                this.y += this.velocityY;
                this.velocityY += 0.2;
                this.life--;
                if (this.life <= 0) this.alive = false;
            }
            
            draw() {
                if (!this.alive) return;
                const alpha = this.life / this.maxLife;
                
                // Glow
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${alpha / 3})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Particle
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Layout generators
        function generateGridLayout() {
            const bricks = [];
            const rows = 5, cols = 10;
            const brickWidth = 70, brickHeight = 25, spacing = 5;
            const totalWidth = cols * brickWidth + (cols - 1) * spacing;
            const startX = (WIDTH - totalWidth) / 2;
            const startY = 50;
            
            for (let row = 0; row < rows; row++) {
                const color = COLOR_ARRAY[row % COLOR_ARRAY.length];
                for (let col = 0; col < cols; col++) {
                    bricks.push(new Brick(
                        startX + col * (brickWidth + spacing),
                        startY + row * (brickHeight + spacing),
                        brickWidth, brickHeight, color
                    ));
                }
            }
            return bricks;
        }
        
        function generateWaveLayout() {
            const bricks = [];
            const rows = 6, cols = 12;
            const brickWidth = 55, brickHeight = 22, spacing = 4;
            const waveAmplitude = 15.0, waveFrequency = 0.3;
            const startY = 50;
            
            for (let row = 0; row < rows; row++) {
                const color = COLOR_ARRAY[row % COLOR_ARRAY.length];
                const phase = row * 0.5;
                for (let col = 0; col < cols; col++) {
                    const waveOffset = Math.sin(col * waveFrequency + phase) * waveAmplitude;
                    const baseX = (WIDTH - (cols * (brickWidth + spacing))) / 2;
                    const x = baseX + col * (brickWidth + spacing) + waveOffset;
                    const y = startY + row * (brickHeight + spacing);
                    if (x >= 0 && x + brickWidth <= WIDTH) {
                        bricks.push(new Brick(x, y, brickWidth, brickHeight, color));
                    }
                }
            }
            return bricks;
        }
        
        function generateCircleLayout() {
            const bricks = [];
            const centerX = WIDTH / 2, centerY = 150;
            const brickWidth = 40, brickHeight = 20;
            const ringRadii = [80, 120, 160];
            const bricksPerRing = [8, 12, 16];
            const startY = 50;
            
            for (let ring = 0; ring < ringRadii.length; ring++) {
                const radius = ringRadii[ring];
                const count = bricksPerRing[ring];
                const color = COLOR_ARRAY[ring % COLOR_ARRAY.length];
                for (let i = 0; i < count; i++) {
                    const angle = (2 * Math.PI / count) * i;
                    const x = centerX + Math.cos(angle) * radius - brickWidth / 2;
                    const y = centerY + Math.sin(angle) * radius - brickHeight / 2;
                    if (x >= 0 && x + brickWidth <= WIDTH && y >= startY && y + brickHeight <= startY + 250) {
                        bricks.push(new Brick(x, y, brickWidth, brickHeight, color));
                    }
                }
            }
            return bricks;
        }
        
        function generateZigZagLayout() {
            const bricks = [];
            const rows = 7, cols = 11;
            const brickWidth = 60, brickHeight = 24, spacing = 5, zigzagOffset = 30;
            const totalWidth = cols * brickWidth + (cols - 1) * spacing;
            const baseStartX = (WIDTH - totalWidth) / 2;
            const startY = 50;
            
            for (let row = 0; row < rows; row++) {
                const color = COLOR_ARRAY[row % COLOR_ARRAY.length];
                const offset = (row % 2 === 0) ? 0 : zigzagOffset;
                const startX = baseStartX + offset;
                const actualCols = (row % 2 === 0) ? cols : cols - 1;
                for (let col = 0; col < actualCols; col++) {
                    const x = startX + col * (brickWidth + spacing);
                    const y = startY + row * (brickHeight + spacing);
                    if (x >= 0 && x + brickWidth <= WIDTH) {
                        bricks.push(new Brick(x, y, brickWidth, brickHeight, color));
                    }
                }
            }
            return bricks;
        }
        
        // Collision detection
        function rectIntersect(r1, r2) {
            return r1.x < r2.x + r2.width && r1.x + r1.width > r2.x &&
                   r1.y < r2.y + r2.height && r1.y + r1.height > r2.y;
        }
        
        // Initialize game
        function initializeGame() {
            const paddleWidth = 100, paddleHeight = 15;
            const paddleX = (WIDTH - paddleWidth) / 2, paddleY = HEIGHT - 50;
            paddle = new Paddle(paddleX, paddleY, paddleWidth, paddleHeight, WIDTH);
            
            const ballRadius = 10;
            const ballX = WIDTH / 2, ballY = HEIGHT - 80;
            ball = new Ball(ballX, ballY, ballRadius);
            
            currentLayoutIndex = 0;
            loadBrickLayout();
            particles = [];
            gameState = GameState.MENU;
            score = 0;
        }
        
        function loadBrickLayout() {
            bricks = layouts[currentLayoutIndex]();
        }
        
        function startGame() {
            if (gameState === GameState.MENU || gameState === GameState.GAME_OVER || gameState === GameState.WIN) {
                initializeGame();
                gameState = GameState.PLAYING;
                ball.reset();
            }
        }
        
        function createParticles(x, y, color) {
            const count = Math.floor(Math.random() * 8) + 5;
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color));
            }
        }
        
        function updateGame() {
            if (gameState !== GameState.PLAYING) return;
            
            // Update paddle
            if (leftPressed) paddle.moveLeft();
            if (rightPressed) paddle.moveRight();
            paddle.update();
            
            // Update ball
            ball.update();
            
            // Wall collisions
            if (ball.x - ball.radius <= 0 || ball.x + ball.radius >= WIDTH) {
                ball.reverseX();
            }
            if (ball.y - ball.radius <= 0) {
                ball.reverseY();
            }
            
            // Paddle collision
            const ballBounds = ball.getBounds();
            const paddleBounds = paddle.getBounds();
            if (rectIntersect(ballBounds, paddleBounds)) {
                const hitPos = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
                const clampedHitPos = Math.max(-1, Math.min(1, hitPos));
                const angle = Math.PI / 2 + clampedHitPos * Math.PI / 3;
                const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
                ball.setVelocity(Math.sin(angle) * speed, -Math.cos(angle) * speed);
                if (ball.velocityY > 0) ball.reverseY();
            }
            
            // Brick collisions
            for (let brick of bricks) {
                if (!brick.destroyed && rectIntersect(ballBounds, brick.getBounds())) {
                    const dx = ball.x - (brick.x + brick.width / 2);
                    const dy = ball.y - (brick.y + brick.height / 2);
                    
                    createParticles(brick.x + brick.width / 2, brick.y + brick.height / 2, brick.color);
                    brick.destroy();
                    score += 10;
                    
                    if (Math.abs(dx) > Math.abs(dy)) {
                        ball.reverseX();
                    } else {
                        ball.reverseY();
                    }
                    break;
                }
            }
            
            // Check win condition
            let allDestroyed = true;
            for (let brick of bricks) {
                if (!brick.destroyed) {
                    allDestroyed = false;
                    break;
                }
            }
            
            if (allDestroyed) {
                currentLayoutIndex++;
                if (currentLayoutIndex >= layouts.length) {
                    gameState = GameState.WIN;
                } else {
                    loadBrickLayout();
                    ball.setPosition(WIDTH / 2, HEIGHT - 80);
                    ball.reset();
                }
            }
            
            // Check game over
            if (ball.y - ball.radius > HEIGHT) {
                gameState = GameState.GAME_OVER;
            }
            
            // Update particles
            particles = particles.filter(p => {
                p.update();
                return p.alive;
            });
        }
        
        function drawUI() {
            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = COLORS.WHITE;
            ctx.fillText('Score: ' + score, 20, 30);
            
            if (gameState === GameState.MENU) {
                drawCenteredText('NEON SHATTER', 40, COLORS.CYAN);
                drawCenteredText('Press ENTER or SPACE to Start', 80, 'rgba(255, 255, 255, 0.78)');
                drawCenteredText('Use Arrow Keys to Move', 110, 'rgba(255, 255, 255, 0.59)');
            } else if (gameState === GameState.GAME_OVER) {
                drawCenteredText('GAME OVER', 40, COLORS.RED);
                drawCenteredText('Final Score: ' + score, 80, 'rgba(255, 255, 255, 0.78)');
                drawCenteredText('Press ENTER to Restart', 110, 'rgba(255, 255, 255, 0.59)');
            } else if (gameState === GameState.WIN) {
                drawCenteredText('YOU WIN!', 40, COLORS.GREEN);
                drawCenteredText('Final Score: ' + score, 80, 'rgba(255, 255, 255, 0.78)');
                drawCenteredText('Press ENTER to Play Again', 110, 'rgba(255, 255, 255, 0.59)');
            }
        }
        
        function drawCenteredText(text, y, color) {
            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = color;
            const metrics = ctx.measureText(text);
            ctx.fillText(text, (WIDTH - metrics.width) / 2, y);
        }
        
        function render() {
            // Clear canvas
            ctx.fillStyle = COLORS.DARK;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            if (gameState === GameState.PLAYING || gameState === GameState.GAME_OVER || gameState === GameState.WIN) {
                // Draw bricks
                bricks.forEach(brick => brick.draw());
                
                // Draw particles
                particles.forEach(particle => particle.draw());
                
                // Draw paddle
                paddle.draw();
                
                // Draw ball
                ball.draw();
            }
            
            // Draw UI
            drawUI();
        }
        
        function gameLoop() {
            updateGame();
            render();
        }
        
        // Event listeners
        canvas.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') leftPressed = true;
            if (e.key === 'ArrowRight') rightPressed = true;
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                startGame();
            }
        });
        
        canvas.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') leftPressed = false;
            if (e.key === 'ArrowRight') rightPressed = false;
        });
        
        canvas.addEventListener('click', () => {
            canvas.focus();
        });
        
        // Initialize and start
        initializeGame();
        setInterval(gameLoop, 1000 / FPS);
        
        // Hide instructions after focus
        canvas.addEventListener('focus', () => {
            document.getElementById('instructions').style.display = 'none';
        });
    </script>
</body>
</html>

