<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Starfall - Play Online</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0a14 0%, #1a1a2e 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
            border: 2px solid rgba(0, 255, 255, 0.2);
        }
        
        canvas {
            display: block;
            background: rgb(5, 5, 20);
        }
        
        #instructions {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            text-align: center;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="instructions">Click on the game to focus, then use Arrow Keys to play</div>
    </div>

    <script>
        // Game Constants
        const WIDTH = 800;
        const HEIGHT = 600;
        const FPS = 60;
        
        // Game State
        const GameState = {
            MENU: 0,
            PLAYING: 1,
            GAME_OVER: 2,
            WIN: 3
        };
        
        // Colors
        const COLORS = {
            CYAN: 'rgba(0, 255, 255, 1)',
            MAGENTA: 'rgba(255, 0, 255, 1)',
            GREEN: 'rgba(0, 255, 0, 1)',
            YELLOW: 'rgba(255, 255, 0, 1)',
            RED: 'rgba(255, 0, 0, 1)',
            WHITE: 'rgba(255, 255, 255, 1)',
            DARK: 'rgb(10, 10, 20)'
        };
        
        const COLOR_ARRAY = [
            {r: 255, g: 255, b: 100},  // Yellow star
            {r: 100, g: 150, b: 255},  // Blue star
            {r: 255, g: 255, b: 255},  // White star
            {r: 200, g: 100, b: 255}   // Purple star
        ];
        
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.tabIndex = 1000;
        canvas.focus();
        
        // Game variables
        let gameState = GameState.MENU;
        let score = 0;
        let currentLayoutIndex = 0;
        let leftPressed = false;
        let rightPressed = false;
        
        // Game objects
        let paddle, ball, bricks = [], particles = [];
        
        // Background effects
        let starParticles = [];
        let nebulaOffset1 = 0;
        let nebulaOffset2 = 0;
        
        // Layout generators
        const layouts = [
            generateGridLayout,
            generateWaveLayout,
            generateCircleLayout,
            generateZigZagLayout
        ];
        
        // Ball class
        class Ball {
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = {r: 150, g: 200, b: 255}; // Comet blue-white
                this.trail = [];
                this.maxTrailLength = 15;
                this.reset();
            }
            
            reset() {
                const angle = Math.random() * Math.PI / 3 + Math.PI / 6;
                const baseSpeed = 4.0;
                this.velocityX = baseSpeed * Math.cos(angle);
                this.velocityY = -baseSpeed * Math.sin(angle);
                this.trail = [];
            }
            
            update() {
                // Add current position to trail
                this.trail.push({x: this.x, y: this.y});
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                
                this.x += this.velocityX;
                this.y += this.velocityY;
            }
            
            reverseX() { this.velocityX = -this.velocityX; }
            reverseY() { this.velocityY = -this.velocityY; }
            
            setVelocity(vx, vy) {
                const speed = Math.sqrt(vx * vx + vy * vy);
                const maxSpeed = 7.0;
                if (speed > maxSpeed) {
                    vx = (vx / speed) * maxSpeed;
                    vy = (vy / speed) * maxSpeed;
                }
                this.velocityX = vx;
                this.velocityY = vy;
            }
            
            setPosition(x, y) {
                this.x = x;
                this.y = y;
            }
            
            getBounds() {
                return {
                    x: this.x - this.radius,
                    y: this.y - this.radius,
                    width: this.radius * 2,
                    height: this.radius * 2
                };
            }
            
            draw() {
                // Draw motion trail (fading tail)
                if (this.trail.length > 1) {
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const p = this.trail[i];
                        const alpha = (i + 1) / this.trail.length * 0.6;
                        const trailSize = this.radius * 0.5 * alpha;
                        ctx.fillStyle = `rgba(150, 200, 255, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, trailSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Draw comet glow effect
                for (let i = 5; i > 0; i--) {
                    const alpha = Math.max(10, 80 / i) / 255;
                    const glowRadius = this.radius + i * 2;
                    ctx.fillStyle = `rgba(150, 200, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, glowRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw main comet orb
                ctx.fillStyle = `rgb(${this.color.r}, ${this.color.g}, ${this.color.b})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw bright core
                ctx.fillStyle = 'rgba(255, 255, 255, 0.78)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.6, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Paddle class
        class Paddle {
            constructor(x, y, width, height, screenWidth) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.screenWidth = screenWidth;
                this.color = {r: 200, g: 200, b: 255}; // Spaceship color
                this.velocity = 0;
                this.acceleration = 0.5;
                this.friction = 0.85;
                this.maxSpeed = 8.0;
                this.movingLeft = false;
                this.movingRight = false;
            }
            
            moveLeft() {
                this.velocity -= this.acceleration;
                if (this.velocity < -this.maxSpeed) this.velocity = -this.maxSpeed;
                this.movingLeft = true;
                this.movingRight = false;
            }
            
            moveRight() {
                this.velocity += this.acceleration;
                if (this.velocity > this.maxSpeed) this.velocity = this.maxSpeed;
                this.movingRight = true;
                this.movingLeft = false;
            }
            
            update() {
                this.velocity *= this.friction;
                if (Math.abs(this.velocity) < 0.1) {
                    this.velocity = 0;
                    this.movingLeft = false;
                    this.movingRight = false;
                }
                this.x += this.velocity;
                
                if (this.x < 0) {
                    this.x = 0;
                    this.velocity = 0;
                } else if (this.x + this.width > this.screenWidth) {
                    this.x = this.screenWidth - this.width;
                    this.velocity = 0;
                }
            }
            
            getBounds() {
                return { x: this.x, y: this.y, width: this.width, height: this.height };
            }
            
            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                
                // Draw flame trail when moving
                if (this.movingLeft) {
                    this.drawFlameTrail(centerX, centerY, 1);
                } else if (this.movingRight) {
                    this.drawFlameTrail(centerX, centerY, -1);
                }
                
                // Draw spaceship glow
                for (let i = 3; i > 0; i--) {
                    const alpha = 40 / i / 255;
                    ctx.fillStyle = `rgba(200, 200, 255, ${alpha})`;
                    const shipX = [centerX, this.x - i, this.x + this.width + i];
                    const shipY = [this.y - i, this.y + this.height + i, this.y + this.height + i];
                    ctx.beginPath();
                    ctx.moveTo(shipX[0], shipY[0]);
                    ctx.lineTo(shipX[1], shipY[1]);
                    ctx.lineTo(shipX[2], shipY[2]);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Draw spaceship body (triangle)
                const shipX = [centerX, this.x, this.x + this.width];
                const shipY = [this.y, this.y + this.height, this.y + this.height];
                ctx.fillStyle = `rgb(${this.color.r}, ${this.color.g}, ${this.color.b})`;
                ctx.beginPath();
                ctx.moveTo(shipX[0], shipY[0]);
                ctx.lineTo(shipX[1], shipY[1]);
                ctx.lineTo(shipX[2], shipY[2]);
                ctx.closePath();
                ctx.fill();
                
                // Draw cockpit window
                ctx.fillStyle = 'rgba(100, 150, 255, 0.71)';
                ctx.beginPath();
                ctx.arc(centerX, this.y + 2, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw spaceship outline
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.78)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(shipX[0], shipY[0]);
                ctx.lineTo(shipX[1], shipY[1]);
                ctx.lineTo(shipX[2], shipY[2]);
                ctx.closePath();
                ctx.stroke();
            }
            
            drawFlameTrail(centerX, centerY, direction) {
                const startX = direction > 0 ? this.x + this.width : this.x;
                const flameLength = 15;
                for (let i = 0; i < flameLength; i++) {
                    const alpha = 1.0 - i / flameLength;
                    const flameX = startX + direction * i * 2;
                    const flameWidth = 8 * alpha;
                    const flameHeight = 6 * alpha;
                    ctx.fillStyle = `rgba(255, ${200 + 55 * alpha}, ${100 * alpha}, ${alpha * 0.78})`;
                    ctx.beginPath();
                    ctx.arc(flameX, centerY, flameWidth / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            drawRoundedRect(x, y, w, h, r) {
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + w - r, y);
                ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                ctx.lineTo(x + w, y + h - r);
                ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                ctx.lineTo(x + r, y + h);
                ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                ctx.lineTo(x, y + r);
                ctx.quadraticCurveTo(x, y, x + r, y);
                ctx.closePath();
                ctx.fill();
            }
        }
        
        // Brick class
        class Brick {
            constructor(x, y, width, height, color) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.destroyed = false;
                this.flashTimer = 0;
                this.twinklePhase = Math.random() * Math.PI * 2;
            }
            
            flash() {
                this.flashTimer = 3; // 3 frames at 60fps = ~50ms
            }
            
            update() {
                if (this.flashTimer > 0) {
                    this.flashTimer--;
                }
                this.twinklePhase += 0.15;
            }
            
            destroy() { this.destroyed = true; }
            
            getBounds() {
                return { x: this.x, y: this.y, width: this.width, height: this.height };
            }
            
            draw() {
                if (this.destroyed) return;
                
                // Update twinkle effect
                const twinkleAlpha = 0.7 + 0.3 * Math.sin(this.twinklePhase);
                
                // Flash effect when hit
                let drawColor = this.color;
                if (this.flashTimer > 0) {
                    drawColor = {r: 255, g: 255, b: 255}; // Flash white
                }
                
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                const starSize = Math.max(this.width, this.height) / 2;
                
                // Draw soft halo around star
                for (let i = 5; i > 0; i--) {
                    const alpha = (60 / i) * twinkleAlpha / 255;
                    const haloSize = starSize + i * 3;
                    ctx.fillStyle = `rgba(${drawColor.r}, ${drawColor.g}, ${drawColor.b}, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, haloSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw star sprite (4-pointed star)
                this.drawStar(centerX, centerY, starSize, drawColor, twinkleAlpha);
            }
            
            drawStar(centerX, centerY, size, color, alpha) {
                const xPoints = [];
                const yPoints = [];
                
                // Create 4-pointed star
                for (let i = 0; i < 8; i++) {
                    const angle = i * Math.PI / 4;
                    const radius = (i % 2 === 0) ? size : size / 2;
                    xPoints.push(centerX + radius * Math.cos(angle));
                    yPoints.push(centerY + radius * Math.sin(angle));
                }
                
                // Draw star with alpha
                ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`;
                ctx.beginPath();
                ctx.moveTo(xPoints[0], yPoints[0]);
                for (let i = 1; i < 8; i++) {
                    ctx.lineTo(xPoints[i], yPoints[i]);
                }
                ctx.closePath();
                ctx.fill();
                
                // Draw bright center
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.78})`;
                ctx.beginPath();
                ctx.arc(centerX, centerY, size / 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            drawRoundedRect(x, y, w, h, r) {
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + w - r, y);
                ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                ctx.lineTo(x + w, y + h - r);
                ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                ctx.lineTo(x + r, y + h);
                ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                ctx.lineTo(x, y + r);
                ctx.quadraticCurveTo(x, y, x + r, y);
                ctx.closePath();
                ctx.fill();
            }
        }
        
        // Particle class
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = Math.random() * 4 + 2;
                this.maxLife = Math.random() * 20 + 15;
                this.life = this.maxLife;
                this.alive = true;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 2;
                this.velocityX = Math.cos(angle) * speed;
                this.velocityY = Math.sin(angle) * speed;
            }
            
            update() {
                if (!this.alive) return;
                this.x += this.velocityX;
                this.y += this.velocityY;
                this.velocityY += 0.2;
                this.life--;
                if (this.life <= 0) this.alive = false;
            }
            
            draw() {
                if (!this.alive) return;
                const alpha = this.life / this.maxLife;
                
                // Glow
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${alpha / 3})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Particle
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Layout generators
        function generateGridLayout() {
            const bricks = [];
            const rows = 5, cols = 10;
            const brickWidth = 70, brickHeight = 25, spacing = 5;
            const totalWidth = cols * brickWidth + (cols - 1) * spacing;
            const startX = (WIDTH - totalWidth) / 2;
            const startY = 50;
            
            for (let row = 0; row < rows; row++) {
                const color = COLOR_ARRAY[row % COLOR_ARRAY.length];
                for (let col = 0; col < cols; col++) {
                    bricks.push(new Brick(
                        startX + col * (brickWidth + spacing),
                        startY + row * (brickHeight + spacing),
                        brickWidth, brickHeight, color
                    ));
                }
            }
            return bricks;
        }
        
        function generateWaveLayout() {
            const bricks = [];
            const rows = 6, cols = 12;
            const brickWidth = 55, brickHeight = 22, spacing = 4;
            const waveAmplitude = 15.0, waveFrequency = 0.3;
            const startY = 50;
            
            for (let row = 0; row < rows; row++) {
                const color = COLOR_ARRAY[row % COLOR_ARRAY.length];
                const phase = row * 0.5;
                for (let col = 0; col < cols; col++) {
                    const waveOffset = Math.sin(col * waveFrequency + phase) * waveAmplitude;
                    const baseX = (WIDTH - (cols * (brickWidth + spacing))) / 2;
                    const x = baseX + col * (brickWidth + spacing) + waveOffset;
                    const y = startY + row * (brickHeight + spacing);
                    if (x >= 0 && x + brickWidth <= WIDTH) {
                        bricks.push(new Brick(x, y, brickWidth, brickHeight, color));
                    }
                }
            }
            return bricks;
        }
        
        function generateCircleLayout() {
            const bricks = [];
            const centerX = WIDTH / 2, centerY = 150;
            const brickWidth = 40, brickHeight = 20;
            const ringRadii = [80, 120, 160];
            const bricksPerRing = [8, 12, 16];
            const startY = 50;
            
            for (let ring = 0; ring < ringRadii.length; ring++) {
                const radius = ringRadii[ring];
                const count = bricksPerRing[ring];
                const color = COLOR_ARRAY[ring % COLOR_ARRAY.length];
                for (let i = 0; i < count; i++) {
                    const angle = (2 * Math.PI / count) * i;
                    const x = centerX + Math.cos(angle) * radius - brickWidth / 2;
                    const y = centerY + Math.sin(angle) * radius - brickHeight / 2;
                    if (x >= 0 && x + brickWidth <= WIDTH && y >= startY && y + brickHeight <= startY + 250) {
                        bricks.push(new Brick(x, y, brickWidth, brickHeight, color));
                    }
                }
            }
            return bricks;
        }
        
        function generateZigZagLayout() {
            const bricks = [];
            const rows = 7, cols = 11;
            const brickWidth = 60, brickHeight = 24, spacing = 5, zigzagOffset = 30;
            const totalWidth = cols * brickWidth + (cols - 1) * spacing;
            const baseStartX = (WIDTH - totalWidth) / 2;
            const startY = 50;
            
            for (let row = 0; row < rows; row++) {
                const color = COLOR_ARRAY[row % COLOR_ARRAY.length];
                const offset = (row % 2 === 0) ? 0 : zigzagOffset;
                const startX = baseStartX + offset;
                const actualCols = (row % 2 === 0) ? cols : cols - 1;
                for (let col = 0; col < actualCols; col++) {
                    const x = startX + col * (brickWidth + spacing);
                    const y = startY + row * (brickHeight + spacing);
                    if (x >= 0 && x + brickWidth <= WIDTH) {
                        bricks.push(new Brick(x, y, brickWidth, brickHeight, color));
                    }
                }
            }
            return bricks;
        }
        
        // Collision detection
        function rectIntersect(r1, r2) {
            return r1.x < r2.x + r2.width && r1.x + r1.width > r2.x &&
                   r1.y < r2.y + r2.height && r1.y + r1.height > r2.y;
        }
        
        // Star particle class for parallax background
        class StarParticle {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.x = Math.random() * 800;
                this.y = Math.random() * 600;
                this.speed = Math.random() * 0.3 + 0.05;
                this.size = Math.floor(Math.random() * 2) + 1;
                this.twinklePhase = Math.random() * Math.PI * 2;
            }
            
            update() {
                this.y += this.speed;
                this.twinklePhase += 0.1;
                if (this.y > 600) {
                    this.reset();
                    this.y = -5;
                }
            }
            
            draw() {
                const alpha = 100 + 50 * Math.sin(this.twinklePhase);
                const clampedAlpha = Math.max(50, Math.min(150, alpha));
                ctx.fillStyle = `rgba(255, 255, 255, ${clampedAlpha / 255})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Nebula layer for parallax
        function drawNebulaLayer(offset, speed, width, height) {
            const colors = [
                {r: 100, g: 50, b: 150, a: 0.08},  // Purple
                {r: 50, g: 100, b: 200, a: 0.06},  // Blue
                {r: 150, g: 50, b: 100, a: 0.07}   // Magenta
            ];
            
            for (let i = 0; i < colors.length; i++) {
                ctx.fillStyle = `rgba(${colors[i].r}, ${colors[i].g}, ${colors[i].b}, ${colors[i].a})`;
                const x = (offset + i * 200) % (width + 400) - 200;
                ctx.beginPath();
                ctx.arc(x, height / 4, 200, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x + 300, height / 2, 175, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Initialize game
        function initializeGame() {
            const paddleWidth = 100, paddleHeight = 15;
            const paddleX = (WIDTH - paddleWidth) / 2, paddleY = HEIGHT - 50;
            paddle = new Paddle(paddleX, paddleY, paddleWidth, paddleHeight, WIDTH);
            
            const ballRadius = 10;
            const ballX = WIDTH / 2, ballY = HEIGHT - 80;
            ball = new Ball(ballX, ballY, ballRadius);
            
            currentLayoutIndex = 0;
            loadBrickLayout();
            particles = [];
            gameState = GameState.MENU;
            score = 0;
            
            // Initialize background star particles
            starParticles = [];
            for (let i = 0; i < 100; i++) {
                starParticles.push(new StarParticle());
            }
            nebulaOffset1 = 0;
            nebulaOffset2 = 0;
        }
        
        function loadBrickLayout() {
            bricks = layouts[currentLayoutIndex]();
        }
        
        function startGame() {
            if (gameState === GameState.MENU || gameState === GameState.GAME_OVER || gameState === GameState.WIN) {
                initializeGame();
                gameState = GameState.PLAYING;
                ball.reset();
            }
        }
        
        function createParticles(x, y, color) {
            const count = Math.floor(Math.random() * 8) + 5;
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color));
            }
        }
        
        function updateGame() {
            if (gameState !== GameState.PLAYING) return;
            
            // Update paddle
            if (leftPressed) paddle.moveLeft();
            if (rightPressed) paddle.moveRight();
            paddle.update();
            
            // Update ball
            ball.update();
            
            // Wall collisions
            if (ball.x - ball.radius <= 0 || ball.x + ball.radius >= WIDTH) {
                ball.reverseX();
            }
            if (ball.y - ball.radius <= 0) {
                ball.reverseY();
            }
            
            // Paddle collision
            const ballBounds = ball.getBounds();
            const paddleBounds = paddle.getBounds();
            if (rectIntersect(ballBounds, paddleBounds)) {
                const hitPos = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
                const clampedHitPos = Math.max(-1, Math.min(1, hitPos));
                const angle = Math.PI / 2 + clampedHitPos * Math.PI / 3;
                const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
                ball.setVelocity(Math.sin(angle) * speed, -Math.cos(angle) * speed);
                if (ball.velocityY > 0) ball.reverseY();
            }
            
            // Brick collisions
            for (let brick of bricks) {
                if (!brick.destroyed && rectIntersect(ballBounds, brick.getBounds())) {
                    const dx = ball.x - (brick.x + brick.width / 2);
                    const dy = ball.y - (brick.y + brick.height / 2);
                    
                    // Flash brick
                    brick.flash();
                    
                    createParticles(brick.x + brick.width / 2, brick.y + brick.height / 2, brick.color);
                    brick.destroy();
                    score += 10;
                    
                    if (Math.abs(dx) > Math.abs(dy)) {
                        ball.reverseX();
                    } else {
                        ball.reverseY();
                    }
                    break;
                }
            }
            
            // Update bricks (for flash effect)
            for (let brick of bricks) {
                brick.update();
            }
            
            // Update background effects
            nebulaOffset1 += 0.3;
            nebulaOffset2 += 0.5;
            if (nebulaOffset1 > 1000) nebulaOffset1 = 0;
            if (nebulaOffset2 > 1000) nebulaOffset2 = 0;
            for (let p of starParticles) {
                p.update();
            }
            
            // Check win condition
            let allDestroyed = true;
            for (let brick of bricks) {
                if (!brick.destroyed) {
                    allDestroyed = false;
                    break;
                }
            }
            
            if (allDestroyed) {
                currentLayoutIndex++;
                if (currentLayoutIndex >= layouts.length) {
                    gameState = GameState.WIN;
                } else {
                    loadBrickLayout();
                    ball.setPosition(WIDTH / 2, HEIGHT - 80);
                    ball.reset();
                }
            }
            
            // Check game over
            if (ball.y - ball.radius > HEIGHT) {
                gameState = GameState.GAME_OVER;
            }
            
            // Update particles
            particles = particles.filter(p => {
                p.update();
                return p.alive;
            });
        }
        
        function drawUI() {
            // Score font - Verdana (Exo 2 fallback)
            ctx.font = 'bold 24px Verdana';
            ctx.fillStyle = 'rgba(0, 255, 255, 1)'; // Neon cyan
            
            // Draw score with glow
            const scoreText = 'Score: ' + score;
            ctx.fillStyle = 'rgba(0, 255, 255, 0.39)';
            ctx.fillText(scoreText, 22, 32);
            ctx.fillStyle = 'rgba(0, 255, 255, 1)';
            ctx.fillText(scoreText, 20, 30);
            
            if (gameState === GameState.MENU) {
                // Title font - Segoe UI (Orbitron fallback)
                ctx.font = 'bold 56px "Segoe UI"';
                drawCenteredText('COSMIC STARFALL', 80, 'rgba(0, 255, 255, 1)');
                
                // Button font - Segoe UI
                ctx.font = '18px "Segoe UI"';
                drawCenteredText('Press ENTER or SPACE to Start', 140, 'rgba(255, 255, 255, 0.86)');
                drawCenteredText('Use Arrow Keys to Move', 170, 'rgba(255, 255, 255, 0.71)');
            } else if (gameState === GameState.GAME_OVER) {
                ctx.font = 'bold 56px "Segoe UI"';
                drawCenteredText('GAME OVER', 80, 'rgba(255, 100, 100, 1)');
                
                ctx.font = '18px "Segoe UI"';
                drawCenteredText('Final Score: ' + score, 140, 'rgba(255, 255, 255, 0.86)');
                drawCenteredText('Press ENTER to Restart', 170, 'rgba(255, 255, 255, 0.71)');
            } else if (gameState === GameState.WIN) {
                ctx.font = 'bold 56px "Segoe UI"';
                drawCenteredText('VICTORY!', 80, 'rgba(255, 255, 100, 1)');
                
                ctx.font = '18px "Segoe UI"';
                drawCenteredText('Final Score: ' + score, 140, 'rgba(255, 255, 255, 0.86)');
                drawCenteredText('Press ENTER to Play Again', 170, 'rgba(255, 255, 255, 0.71)');
            }
        }
        
        function drawCenteredText(text, y, color) {
            ctx.fillStyle = color;
            const metrics = ctx.measureText(text);
            ctx.fillText(text, (WIDTH - metrics.width) / 2, y);
        }
        
        function render() {
            // Draw deep space background
            const bgGradient = ctx.createLinearGradient(0, 0, 0, HEIGHT);
            bgGradient.addColorStop(0, 'rgb(5, 5, 20)');
            bgGradient.addColorStop(1, 'rgb(10, 5, 30)');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            // Draw parallax nebula layers (2 layers scrolling at different speeds)
            drawNebulaLayer(nebulaOffset1, 0.3, WIDTH, HEIGHT);
            drawNebulaLayer(nebulaOffset2, 0.5, WIDTH, HEIGHT);
            
            // Draw twinkling star particles
            for (let p of starParticles) {
                p.draw();
            }
            
            if (gameState === GameState.PLAYING || gameState === GameState.GAME_OVER || gameState === GameState.WIN) {
                // Draw bricks
                bricks.forEach(brick => brick.draw());
                
                // Draw particles
                particles.forEach(particle => particle.draw());
                
                // Draw paddle
                paddle.draw();
                
                // Draw ball
                ball.draw();
            }
            
            // Draw UI
            drawUI();
        }
        
        function gameLoop() {
            updateGame();
            render();
        }
        
        // Event listeners
        canvas.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') leftPressed = true;
            if (e.key === 'ArrowRight') rightPressed = true;
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                startGame();
            }
        });
        
        canvas.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') leftPressed = false;
            if (e.key === 'ArrowRight') rightPressed = false;
        });
        
        canvas.addEventListener('click', () => {
            canvas.focus();
        });
        
        // Initialize and start
        initializeGame();
        setInterval(gameLoop, 1000 / FPS);
        
        // Hide instructions after focus
        canvas.addEventListener('focus', () => {
            document.getElementById('instructions').style.display = 'none';
        });
    </script>
</body>
</html>

